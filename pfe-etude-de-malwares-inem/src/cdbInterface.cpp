/**
 * @file cdbInterface.cpp
 * @author Damien HEURET
 * @brief Interface between our program and CDB process
 * @version 0.1
 * @date 2022-01-11
 * 
 * @copyright Copyright (c) 2022
 * 
 */
#include "../include/cdbInterface.h"

/**
 * @brief Construct a new CDBInterface::CDBInterface object
 * 
 * @param attach the name of process which CDB will attach
 */
CDBInterface::CDBInterface(std::string attach)
{
    isRunning = false;

    // Security Attributes : 
    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    // Doit-on hérité des HANDLES ? (Oui pour rediriger les sorties et les entrées)
    saAttr.bInheritHandle = TRUE;
    // ça osef
    saAttr.lpSecurityDescriptor = NULL;

    // Création des pipes : h = HANDLE ; CDB <- Nom Processus Fils; IN/OUT <- Entrée ou Sortie de la sortie; rd/wr <- Sortie ou Entrée par rapport à notre programme.
    hCDB_IN_rd = NULL;
    hCDB_IN_wr = NULL;
    hCDB_OUT_rd = NULL;
    hCDB_OUT_wr = NULL;

    // Création des pipes
    CreatePipe(&hCDB_OUT_rd, &hCDB_OUT_wr, &saAttr, 0);
    CreatePipe(&hCDB_IN_rd, &hCDB_IN_wr, &saAttr, 0);

    // Startup information :
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(si);
    // On utilise les handles, et la synchronisation
    si.dwFlags = STARTF_USESTDHANDLES | SYNCHRONIZE;
    // Setup des entrées et sorties standard (redirection sur les pipes)
    si.hStdInput = hCDB_IN_rd;
    si.hStdOutput = hCDB_OUT_wr;
    si.hStdError = hCDB_OUT_wr;

    // On stock le nom du fichier sur lequel on doit s'attacher.
    processToDebug = attach;

    // Commande pour lancer CDB
    cmdLine = "cdb -pn " + processToDebug;
}

/**
 * @brief Destroy the CDBInterface::CDBInterface object
 * 
 */
CDBInterface::~CDBInterface() {
    CloseHandle(hCDB_OUT_rd);
    CloseHandle(hCDB_IN_wr);
}

/**
 * @brief Exécute CDB
 * 
 */
void CDBInterface::run() {
    isRunning = true;

    CreateProcess(NULL,
        const_cast<char *>(cmdLine.c_str()),
        NULL,
        NULL,
        TRUE,
        NORMAL_PRIORITY_CLASS,
        NULL,
        NULL,
        &si,
        &pi);

    // Ferme les pipes du côté du fils. (On ne peut pas écrire et lire dans les mêmes côtés du pipe que le fils.)
    CloseHandle(hCDB_OUT_wr);
    CloseHandle(hCDB_IN_rd);
}

/**
 * @brief Stop CDB
 * 
 */
void CDBInterface::stop() {
    isRunning = false;
    TerminateProcess(pi.hProcess, 0);
}

/**
 * @brief Sends command to cdb
 * 
 * @param command the command to send
 */
void CDBInterface::send(std::string command) {
    command += "\n";
    DWORD bytesWritten;
    DWORD bSuccess;
    std::cout << "COMMAND SEND : "<<command<<std::endl;
    bSuccess = WriteFile(hCDB_IN_wr, command.c_str(), command.length(), &bytesWritten, NULL);
    if (!bSuccess || bytesWritten == 0) {
        std::cout << "ERROR IN WRITEFILE : " << GetLastError() << std::endl;
    }
}

/**
 * @brief Receive data from CDB until it waits for inputs.
 * 
 */
std::string CDBInterface::recv() {
    std::regex endRegex("[0-9]:[0-9]+>");
    std::smatch m;
    DWORD hasNbytes;
    DWORD result = 0;
    DWORD ok = 1;
    // while useless
    int counter = 0;

    COMMTIMEOUTS timeouts = { 0, //interval timeout. 0 = not used
                              0, // read multiplier
                             10, // read constant (milliseconds)
                              0, // Write multiplier
                              0  // Write Constant
                            };
    SetCommTimeouts(hCDB_OUT_rd, &timeouts);
    std::string output;
    while (result != 258 && ok) {
        // On attends qu'il y ai écriture dans le buffer pendant un certains temps
        result = WaitForMultipleObjects(1, &hCDB_OUT_rd, FALSE, 500);
        if(result == 258){
            // std::cout <<"Error 258 in recv "<<std::endl;
            break;
        }
        // std::cout <<"result for waitForMultipleObjects :"<<result <<std::endl;
        // On lit le buffer (la pipe)
        
        ok = ReadFile(hCDB_OUT_rd, buffer, CDB_BUFFER_SIZE, &hasNbytes, NULL);
        // if (hasNbytes == 0) {
        //     std::cout << "TIMEOUT of READFILE"<<std::endl;
        // }
        
        // On créé une copie du buffer
        std::string msg(buffer, hasNbytes);
        // On l'affiche
        std::cout << msg;
        output = msg;
        // Si CDB attends une entrée, on sort de la boucle. UTILISATION DES REGEX NECESSAIRES
        if (msg.rfind(">") == 5 || msg.rfind(">") == 9)
            break;
        // Utilisation de regex !! :) Je crois que ça marche
        if (std::regex_search(msg, m, endRegex)) {
            break;
        }
        counter++;
        if(counter>10){
            // break;
        }
    }
    // std::cout <<"fin of recv :"<<std::endl;
    ZeroMemory(buffer, CDB_BUFFER_SIZE);
    // std::cout << "NOUS SOMMES SORTIE" << std::endl;
    // bufSize, &hasNbytes, NULL);
    return output;
}

/**
 * @brief Receive data from CDB until it waits for inputs. Act like other but dont use counter
 * 
 */
std::string CDBInterface::recv_without_break_condition(bool needDisplay = false) {
    std::regex endRegex("[0-9]:[0-9]+>");
    std::smatch m;
    DWORD hasNbytes;
    DWORD result = 0;
    DWORD ok = 1;
    // while useless
    int counter = 0;

    COMMTIMEOUTS timeouts = { 0, //interval timeout. 0 = not used
                              0, // read multiplier
                             10, // read constant (milliseconds)
                              0, // Write multiplier
                              0  // Write Constant
                            };
    SetCommTimeouts(hCDB_OUT_rd, &timeouts);
    // std::cout <<"Start of recv_without_break_condition :"<<std::endl;
    std::string output;
    while (result != 258 && ok) {
        // On attends qu'il y ai écriture dans le buffer pendant un certains temps
        result = WaitForMultipleObjects(1, &hCDB_OUT_rd, FALSE, 1000);

        // On lit le buffer (la pipe)        
        ok = ReadFile(hCDB_OUT_rd, buffer, CDB_BUFFER_SIZE, &hasNbytes, NULL);
        // if (hasNbytes == 0) {
        //     std::cout << "TIMEOUT of READFILE"<<std::endl;
        // }
        
        // On créé une copie du buffer
        std::string msg(buffer, hasNbytes);
        output = msg;
        // On l'affiche
        if(needDisplay){
            std::cout << msg<<std::endl;
        }

        
        // Si CDB attends une entrée, on sort de la boucle. UTILISATION DES REGEX NECESSAIRES
        if (msg.rfind(">") == 5 || msg.rfind(">") == 9)
            std::cout<<"msg rfind "<<std::endl;
            break;
        // Utilisation de regex !! :) Je crois que ça marche
        if (std::regex_search(msg, m, endRegex)) {
            std::cout<<"search"<<std::endl;
            break;
        }

    }
    // std::cout <<"fin of recv_without_break_condition :"<<std::endl;
    ZeroMemory(buffer, CDB_BUFFER_SIZE);
    // std::cout << "NOUS SOMMES SORTIE" << std::endl;
    // bufSize, &hasNbytes, NULL);
    return output;
}




/**
 * @brief Receive data from CDB until it waits for inputs.
 * @param name_register Nom du registre à lire
 * @return Retourne l'adresse du registre correspondant
 */
std::string CDBInterface::read_register(std::string name_register) {
    std::regex endRegex("[0-9]:[0-9]+>");
    std::smatch m;
    DWORD hasNbytes;
    DWORD result = 0;
    DWORD ok = 1;
    std::string address_found = " NOT FOUND";

    while (result != 258 && ok) {
        // On attends qu'il y ai écriture dans le buffer pendant un certains temps
        result = WaitForMultipleObjects(1, &hCDB_OUT_rd, FALSE, 500);

        ok = ReadFile(hCDB_OUT_rd, buffer, CDB_BUFFER_SIZE, &hasNbytes, NULL);
        std::string msg(buffer, hasNbytes);
        // On l'affiche
        int index = msg.rfind(name_register+"="); 
        // On ajoute à l'index trouvé la taille du pattern + 1 à cause du égal
        int index_beginning = index + name_register.length()+1; 
        //On récupère donc l'adresse
        address_found = msg.substr(index_beginning,8);        
        // Si CDB attends une entrée, on sort de la boucle. UTILISATION DES REGEX NECESSAIRES
        if (msg.rfind(">") == 5 || msg.rfind(">") == 9)
            break;
        // Utilisation de regex !! :) Je crois que ça marche
        if (std::regex_search(msg, m, endRegex)) {
            break;
        }
    }
    std::cout<<"Address found for "<<name_register<<" : "<<address_found<<std::endl;

    ZeroMemory(buffer, CDB_BUFFER_SIZE);
    return address_found;
    // std::cout << "NOUS SOMMES SORTIE" << std::endl;
    // bufSize, &hasNbytes, NULL);
}
/**
 * @brief Receive data from CDB until it waits for inputs.
 * @return Return the for ret address
 * 
 */
std::string CDBInterface::read_address_for_pop_pop_ret() {
    std::regex endRegex("[0-9]:[0-9]+>");
    std::smatch m;
    DWORD hasNbytes;
    DWORD result = 0;
    DWORD ok = 1;
    std::string address_found = " NOT FOUND";
    // COMMTIMEOUTS timeouts = { 0, //interval timeout. 0 = not used
    //                           0, // read multiplier
    //                          10, // read constant (milliseconds)
    //                           0, // Write multiplier
    //                           0  // Write Constant
    //                         };
    // SetCommTimeouts(hCDB_OUT_rd, &timeouts);
    // std::cout << "Start of read_address_for_pop_pop_ret" << std::endl;
    std::string exitMessage; 
    while (result != 258 && ok) {
        // On attends qu'il y ai écriture dans le buffer pendant un certains temps
        result = WaitForMultipleObjects(1, &hCDB_OUT_rd, FALSE, 500);
        // std::cout <<"result for waitForMultipleObjects read register :"<<result <<std::endl;
        // if(result==258){
        //     break;
        // }
        // // On lit le buffer (la pipe)
        ok = ReadFile(hCDB_OUT_rd, buffer, CDB_BUFFER_SIZE, &hasNbytes, NULL);
        // On créé une copie du buffer
        // if (hasNbytes == 0) {
        //     std::cout << "TIMEOUT of READFILE"<<std::endl;
            
        // }

        std::string msg(buffer, hasNbytes);
        exitMessage= msg;// On l'affiche
        // std::cout << msg << std::endl;
        
        
        
        
        // Si CDB attends une entrée, on sort de la boucle. UTILISATION DES REGEX NECESSAIRES
        // if (msg.rfind(">") == 5 || msg.rfind(">") == 9)
            
        //     break;
        // Utilisation de regex !! :) Je crois que ça marche
        // if (std::regex_search(msg, m, endRegex)) {
            
        //     break;
        // }
        
    }
  
    // std::regex addressRegex("[a-zA-Z0-9]{8}  [a-zA-Z0-9]{8}");
    std::regex addressRegex("  [a-zA-Z0-9]{8}");
    std::smatch matches;
    // std::cout<<" FULL MESSAGE :"<<std::endl;
    // std::cout<<exitMessage<<std::endl;
    // std::cout<<"--------------"<<std::endl;
    std::string::const_iterator searchStart( exitMessage.cbegin() );
    // std::cout<<" Search with regex :"<<std::endl;
    int i=0;
    while ( std::regex_search( searchStart, exitMessage.cend(), matches, addressRegex ) )
    {
        if(i==2){//On prend la 3ème + 1 trouvée
            address_found = matches[0];
        }
        // std::cout <<"i : " <<i<<" | "<<matches[0]<<std::endl;
        searchStart = matches.suffix().first;
        ++i;
    }
    // std::cout << std::endl;
    // std::cout<<" End with regex"<<std::endl;
    // std::regex_search(exitMessage, matches, addressRegex);

    
    // for (auto x : matches) 
    //     std::cout << x << " ";
    // std::cout<<"size : "<<matches.size()<<std::endl;

    
    std::string delimiter = " ";
    
    // std::string token;
    
    
    // size_t pos = exitMessage.find(delimiter);
    // std::cout<<"pos : "<<pos<<std::endl;
    // token = address_found.substr(0, pos);
    // std::cout <<"token during while : "<< token << std::endl;
    address_found =address_found.substr(2, 10);
    
    // std::cout<< "address found : "<<token<<std::endl;
    ZeroMemory(buffer, CDB_BUFFER_SIZE);
    // std::cout << "END of read_address_for_pop_pop_ret" << std::endl;
    return address_found;
    
    // bufSize, &hasNbytes, NULL);
}





/**
 * @brief Receive data from CDB until it waits for inputs.
 * Search for all badchar
 * 
 * @return Return the rank of badchar if finded. If all char are correct, return 0
 */
int CDBInterface::read_bad_char_output(std::string badCharSended,int rankOfBadChar) {
    std::regex endRegex("[0-9]:[0-9]+>");
    std::smatch m;
    DWORD hasNbytes;
    DWORD result = 0;
    DWORD ok = 1;
    std::string address_found = " NOT FOUND";
    // COMMTIMEOUTS timeouts = { 0, //interval timeout. 0 = not used
    //                           0, // read multiplier
    //                          10, // read constant (milliseconds)
    //                           0, // Write multiplier
    //                           0  // Write Constant
    //                         };
    // SetCommTimeouts(hCDB_OUT_rd, &timeouts);
    std::cout << "Start of read_bad_char_output" << std::endl;
    std::string exitMessage; 
    while (result != 258 && ok) {
        // On attends qu'il y ai écriture dans le buffer pendant un certains temps
        result = WaitForMultipleObjects(1, &hCDB_OUT_rd, FALSE, 500);
        // std::cout <<"result for waitForMultipleObjects read register :"<<result <<std::endl;
        // if(result==258){
        //     break;
        // }
        // // On lit le buffer (la pipe)
        ok = ReadFile(hCDB_OUT_rd, buffer, CDB_BUFFER_SIZE, &hasNbytes, NULL);
        // On créé une copie du buffer
        // if (hasNbytes == 0) {
        //     std::cout << "TIMEOUT of READFILE"<<std::endl;
            
        // }

        std::string msg(buffer, hasNbytes);
        exitMessage= msg;// On l'affiche
        // std::cout << msg << std::endl;
        
        
        
        
        // Si CDB attends une entrée, on sort de la boucle. UTILISATION DES REGEX NECESSAIRES
        // if (msg.rfind(">") == 5 || msg.rfind(">") == 9)
            
        //     break;
        // Utilisation de regex !! :) Je crois que ça marche
        // if (std::regex_search(msg, m, endRegex)) {
            
        //     break;
        // }
        
    }
  
    // std::regex addressRegex("[a-zA-Z0-9]{8}  [a-zA-Z0-9]{8}");
    std::regex addressRegex("  [a-zA-Z0-9]{8}");
    std::smatch matches;
    // std::cout<<" FULL MESSAGE :"<<std::endl;
    // std::cout<<exitMessage<<std::endl;
    // std::cout<<"--------------"<<std::endl;
    std::string::const_iterator searchStart( exitMessage.cbegin() );
    // std::cout<<" Search with regex :"<<std::endl;
    int i=0;
    
    std::string char1,char2,char3,char4,badChar1,badChar2,badChar3,badChar4;
    
    //Will turn on when find 43, so the beginning of our badchar
    bool detectAddressOf43 = FALSE;

    int rankOfLastGoodCharacter = 0;
     
    while ( std::regex_search( searchStart, exitMessage.cend(), matches, addressRegex ) )
    {
        address_found = matches[0];
        address_found =address_found.substr(2, 10);
        // std::cout <<"i : " <<i<<" | "<<address_found<<std::endl;

        if(address_found == "44444444"){
            break;
        }
        if(detectAddressOf43 ){
            
            
            // std::cout <<"badcharSended : " <<badChar1<<std::endl;
            SaveParser saveParser;

            badChar1 = saveParser.convert_int_to_string_in_hex(rankOfBadChar);
            badChar2 = saveParser.convert_int_to_string_in_hex(rankOfBadChar+1);
            badChar3 = saveParser.convert_int_to_string_in_hex(rankOfBadChar+2);
            badChar4 = saveParser.convert_int_to_string_in_hex(rankOfBadChar+3);
                        
            // badChar1 = badCharSended.substr(rankOfLastGoodCharacter,2);
            // badChar2 = badCharSended.substr(rankOfLastGoodCharacter+2,2);
            // badChar3 = badCharSended.substr(rankOfLastGoodCharacter+4,2);
            // badChar4 = badCharSended.substr(rankOfLastGoodCharacter+6,2);
            
            char1 = address_found.substr(6,2);
            char2 = address_found.substr(4,2);
            char3 = address_found.substr(2,2);
            char4 = address_found.substr(0,2);
            // std::cout<<"char1 : "<<char1;
            // std::cout<<"| char2 : "<<char2;
            // std::cout<<"| char3 : "<<char3;
            // std::cout<<"| char4 : "<<char4<<std::endl;
            // std::cout<<"badchar1 : "<<badChar1;
            // std::cout<<"|badchar2 : "<<badChar2;
            // std::cout<<"|badchar3 : "<<badChar3;
            // std::cout<<"|badchar4 : "<<badChar4<<std::endl;
            //On va vérifier que les charactères trouvés correspondent au caractères envoyés
            if(char1!=badChar1){
                return rankOfBadChar-1;
            }
            if(char2!=badChar2){
                return rankOfBadChar;
            }
            if(char3!=badChar3){
                return rankOfBadChar+1;
            }
            if(char4!=badChar4){
                return rankOfBadChar+2;
            }
            //Si tous les charactères sont bon, on poursuit
            rankOfBadChar+=4;
        }

        //Permet de savoir quand l'on peut commencer la recherche
        if(address_found=="43434343"){
            detectAddressOf43= true;    
        }

        searchStart = matches.suffix().first;
        ++i;
    }
    // std::cout << std::endl;
    std::cout<<" End with regex"<<std::endl;
    // std::cout<< "address found : "<<token<<std::endl;
    ZeroMemory(buffer, CDB_BUFFER_SIZE);
    // std::cout << "END of read_bad_char_output" << std::endl;
    return -1;
    
    // bufSize, &hasNbytes, NULL);
}

/**
 * @brief Read narly output to check good library to use
 * 
 */
std::list<std::string> CDBInterface::recv_read_narly_output() {
    std::regex endRegex("[0-9]:[0-9]+>");
    std::smatch m;
    DWORD hasNbytes;
    DWORD result = 0;
    DWORD ok = 1;
    // while useless
    int counter = 0;

    COMMTIMEOUTS timeouts = { 0, //interval timeout. 0 = not used
                              0, // read multiplier
                             10, // read constant (milliseconds)
                              0, // Write multiplier
                              0  // Write Constant
                            };
    SetCommTimeouts(hCDB_OUT_rd, &timeouts);
    // std::cout <<"recv_read_narly_output :"<<std::endl;
    std::string output ="";
    while (result != 258 && ok) {
        // On attends qu'il y ai écriture dans le buffer pendant un certains temps
        result = WaitForMultipleObjects(1, &hCDB_OUT_rd, FALSE, 1000);

        // On lit le buffer (la pipe)        
        ok = ReadFile(hCDB_OUT_rd, buffer, CDB_BUFFER_SIZE, &hasNbytes, NULL);
        // if (hasNbytes == 0) {
        //     std::cout << "TIMEOUT of READFILE"<<std::endl;
        // }
        
        // On créé une copie du buffer
        std::string msg(buffer, hasNbytes);
        output = msg;
        // On l'affiche
        // if(needDisplay){
        //     std::cout << msg<<"-----"<<std::endl;
        // }

        
        // Si CDB attends une entrée, on sort de la boucle. UTILISATION DES REGEX NECESSAIRES
        if (msg.rfind(">") == 5 || msg.rfind(">") == 9)
            // std::cout<<"msg rfind "<<std::endl;
            break;
        // Utilisation de regex !! :) Je crois que ça marche
        if (std::regex_search(msg, m, endRegex)) {
            // std::cout<<"search"<<std::endl;
            break;
        }

    }
    


    size_t pos2 = 0;
    std::string delimeter = "\n";
    std::string token;
    // std::cout<<"Output : "<<std::endl;
    std::list<std::string> list_of_library;
    while((pos2 = output.find(delimeter) )!=std::string::npos){
        token = output.substr(0,pos2);
        // std::cout<<"token : "<<token<<std::endl;

            //On cherche tous les lignes qui ont le terme SafeSEH off afin de trouver les addresses
            int pos = output.find("/SafeSEH OFF");
            if(pos!=-1){
                
                std::string borne_librairie = output.substr(pos-39,17);
                list_of_library.push_back(borne_librairie);
            }


        output.erase(0,pos2+delimeter.length());
    }
    // std::list<std::string>::iterator it;
    //     for (it = list_of_library.begin(); it != list_of_library.end(); ++it)
    //         std::cout<<*it<<std::endl;

    // std::cout<<output<<std::endl;
    // std::cout<<"Output end"<<std::endl;

    // std::cout<<borne_librairie<<std::endl;
    // std::cout <<"fin of recv_read_narly_output"<<std::endl;
    ZeroMemory(buffer, CDB_BUFFER_SIZE);
    // std::cout << "NOUS SOMMES SORTIE" << std::endl;
    // bufSize, &hasNbytes, NULL);
    return list_of_library;
}


/**
 * @brief Receive data from CDB until it waits for inputs. Act like other but dont use counter
 * 
 */
std::list<std::string> CDBInterface::recv_without_break_condition_larger_timeout(bool needDisplay = false) {
    std::regex endRegex("[0-9]:[0-9]+>");
    std::smatch m;
    DWORD hasNbytes;
    DWORD result = 0;
    DWORD ok = 1;
    // while useless
    int counter = 0;

    COMMTIMEOUTS timeouts = { 0, //interval timeout. 0 = not used
                              0, // read multiplier
                             10, // read constant (milliseconds)
                              0, // Write multiplier
                              0  // Write Constant
                            };
    SetCommTimeouts(hCDB_OUT_rd, &timeouts);
    // std::cout <<"Start of recv_without_break_condition_larger_timeout :"<<std::endl;
    std::string output;
    while (result != 258 && ok) {
        // On attends qu'il y ai écriture dans le buffer pendant un certains temps
        result = WaitForMultipleObjects(1, &hCDB_OUT_rd, FALSE, 8000);

        // On lit le buffer (la pipe)        
        ok = ReadFile(hCDB_OUT_rd, buffer, CDB_BUFFER_SIZE, &hasNbytes, NULL);
        // if (hasNbytes == 0) {
        //     std::cout << "TIMEOUT of READFILE"<<std::endl;
        // }
        
        // On créé une copie du buffer
        std::string msg(buffer, hasNbytes);
        output = msg;
        // On l'affiche
        if(needDisplay){
            std::cout << msg<<"-----"<<std::endl;
        }

        
        // Si CDB attends une entrée, on sort de la boucle. UTILISATION DES REGEX NECESSAIRES
        if (msg.rfind(">") == 5 || msg.rfind(">") == 9)
            // std::cout<<"msg rfind "<<std::endl;
            break;
        // Utilisation de regex !! :) Je crois que ça marche
        if (std::regex_search(msg, m, endRegex)) {
            // std::cout<<"search"<<std::endl;
            break;
        }

    }


    size_t pos2 = 0;
    std::string delimeter = "\n";
    std::string token;
    // std::cout<<"Output : "<<std::endl;
    std::list<std::string> list_of_address_pop_pop_ret_possibilities;
    while((pos2 = output.find(delimeter) )!=std::string::npos){
        token = output.substr(0,pos2);
        list_of_address_pop_pop_ret_possibilities.push_back(token);
        output.erase(0,pos2+delimeter.length());
    }


    // std::cout <<"fin of recv_without_break_condition_larger_timeout :"<<std::endl;
    ZeroMemory(buffer, CDB_BUFFER_SIZE);
    return list_of_address_pop_pop_ret_possibilities;
    // std::cout << "NOUS SOMMES SORTIE" << std::endl;
    // bufSize, &hasNbytes, NULL);
}


/**
 * @brief Receive data from CDB until it waits for inputs. Return true if the breakpoint set is failing
 * 
 */
bool CDBInterface::recv_without_break_is_bp_failed(bool needDisplay = false) {
    std::regex endRegex("[0-9]:[0-9]+>");
    std::smatch m;
    DWORD hasNbytes;
    DWORD result = 0;
    DWORD ok = 1;
    // while useless
    int counter = 0;

    COMMTIMEOUTS timeouts = { 0, //interval timeout. 0 = not used
                              0, // read multiplier
                             10, // read constant (milliseconds)
                              0, // Write multiplier
                              0  // Write Constant
                            };
    SetCommTimeouts(hCDB_OUT_rd, &timeouts);
    // std::cout <<"Start of recv_without_break_is_bp_failed :"<<std::endl;
    std::string output;
    while (result != 258 && ok) {
        // On attends qu'il y ai écriture dans le buffer pendant un certains temps
        result = WaitForMultipleObjects(1, &hCDB_OUT_rd, FALSE, 5000);

        // On lit le buffer (la pipe)        
        ok = ReadFile(hCDB_OUT_rd, buffer, CDB_BUFFER_SIZE, &hasNbytes, NULL);
        // if (hasNbytes == 0) {
        //     std::cout << "TIMEOUT of READFILE"<<std::endl;
        // }
        
        // On créé une copie du buffer
        std::string msg(buffer, hasNbytes);
        output = msg;
        // On l'affiche
        if(needDisplay){
            std::cout << msg<<"-----"<<std::endl;
        }

        
        // Si CDB attends une entrée, on sort de la boucle. UTILISATION DES REGEX NECESSAIRES
        if (msg.rfind(">") == 5 || msg.rfind(">") == 9)
            std::cout<<"msg rfind "<<std::endl;
            break;
        // Utilisation de regex !! :) Je crois que ça marche
        if (std::regex_search(msg, m, endRegex)) {
            std::cout<<"search"<<std::endl;
            break;
        }

    }
    
    return (output.find("failed")!=-1);
    // std::cout << "NOUS SOMMES SORTIE" << std::endl;
    // bufSize, &hasNbytes, NULL);
}


/**
 * @brief Receive data from CDB until it waits for inputs. Act like other but dont use counter
 * 
 */
std::string CDBInterface::recv_without_break_condition_for_jump(bool needDisplay = false) {
    std::regex endRegex("[0-9]:[0-9]+>");
    std::smatch m;
    DWORD hasNbytes;
    DWORD result = 0;
    DWORD ok = 1;
    // while useless
    int counter = 0;

    COMMTIMEOUTS timeouts = { 0, //interval timeout. 0 = not used
                              0, // read multiplier
                             10, // read constant (milliseconds)
                              0, // Write multiplier
                              0  // Write Constant
                            };
    SetCommTimeouts(hCDB_OUT_rd, &timeouts);
    // std::cout <<"Start of recv_without_break_condition :"<<std::endl;
    std::string output; 
    while (result != 258 && ok) {
        // On attends qu'il y ai écriture dans le buffer pendant un certains temps
        result = WaitForMultipleObjects(1, &hCDB_OUT_rd, FALSE, 1000);

        // On lit le buffer (la pipe)        
        ok = ReadFile(hCDB_OUT_rd, buffer, CDB_BUFFER_SIZE, &hasNbytes, NULL);
        // if (hasNbytes == 0) {
        //     std::cout << "TIMEOUT of READFILE"<<std::endl;
        // }
        
        // On créé une copie du buffer
        std::string msg(buffer, hasNbytes);
        output = msg;
        // On l'affiche
        if(needDisplay){
            std::cout << msg<<"-----"<<std::endl;
        }

        
        // Si CDB attends une entrée, on sort de la boucle. UTILISATION DES REGEX NECESSAIRES
        if (msg.rfind(">") == 5 || msg.rfind(">") == 9)
            // std::cout<<"msg rfind "<<std::endl;
            break;
        // Utilisation de regex !! :) Je crois que ça marche
        if (std::regex_search(msg, m, endRegex)) {
            // std::cout<<"search"<<std::endl;
            break;
        }

    }
    int pos = output.find("44444444");
    std::string address_for_jmp = output.substr(pos-10,8);
    std::cout<<"address for jmp :"<<address_for_jmp<<std::endl;
    // std::cout <<"fin of recv_without_break_condition :"<<std::endl;
    ZeroMemory(buffer, CDB_BUFFER_SIZE);
    // std::cout << "NOUS SOMMES SORTIE" << std::endl;
    // bufSize, &hasNbytes, NULL);
    return address_for_jmp;
}

/**
 * @brief Receive data from CDB until it waits for inputs. Act like other but dont use counter
 * @return Retourne l'instruction correspondant au short jump (xxeb)
 */
std::string CDBInterface::recv_without_break_condition_for_short_jump(bool needDisplay = false) {
    std::regex endRegex("[0-9]:[0-9]+>");
    std::smatch m;
    DWORD hasNbytes;
    DWORD result = 0;
    DWORD ok = 1;
    // while useless
    int counter = 0;

    COMMTIMEOUTS timeouts = { 0, //interval timeout. 0 = not used
                              0, // read multiplier
                             10, // read constant (milliseconds)
                              0, // Write multiplier
                              0  // Write Constant
                            };
    SetCommTimeouts(hCDB_OUT_rd, &timeouts);
    // std::cout <<"Start of recv_without_break_condition :"<<std::endl;
    std::string output; 
    while (result != 258 && ok) {
        // On attends qu'il y ai écriture dans le buffer pendant un certains temps
        result = WaitForMultipleObjects(1, &hCDB_OUT_rd, FALSE, 1000);

        // On lit le buffer (la pipe)        
        ok = ReadFile(hCDB_OUT_rd, buffer, CDB_BUFFER_SIZE, &hasNbytes, NULL);
        // if (hasNbytes == 0) {
        //     std::cout << "TIMEOUT of READFILE"<<std::endl;
        // }
        
        // On créé une copie du buffer
        std::string msg(buffer, hasNbytes);
        output = msg;
        // On l'affiche
        if(needDisplay){
            std::cout << msg<<"-----"<<std::endl;
        }

        
        // Si CDB attends une entrée, on sort de la boucle. UTILISATION DES REGEX NECESSAIRES
        if (msg.rfind(">") == 5 || msg.rfind(">") == 9)
            // std::cout<<"msg rfind "<<std::endl;
            break;
        // Utilisation de regex !! :) Je crois que ça marche
        if (std::regex_search(msg, m, endRegex)) {
            // std::cout<<"search"<<std::endl;
            break;
        }

    }
    int pos = output.find("eb");
    std::string address_for_jmp = output.substr(pos-2,4);
    std::cout<<"address for jmp :"<<address_for_jmp<<std::endl;
    // std::cout <<"fin of recv_without_break_condition :"<<std::endl;
    ZeroMemory(buffer, CDB_BUFFER_SIZE);
    // std::cout << "NOUS SOMMES SORTIE" << std::endl;
    // bufSize, &hasNbytes, NULL);
    return address_for_jmp;
}


/**
 * @brief Receive data from CDB until it waits for inputs. Act like other but dont use counter
 * 
 */
std::string CDBInterface::recv_without_break_condition_for_stackbase_and_stacklimit(bool needDisplay = false) {
    std::regex endRegex("[0-9]:[0-9]+>");
    std::smatch m;
    DWORD hasNbytes;
    DWORD result = 0;
    DWORD ok = 1;
    // while useless
    int counter = 0;

    COMMTIMEOUTS timeouts = { 0, //interval timeout. 0 = not used
                              0, // read multiplier
                             10, // read constant (milliseconds)
                              0, // Write multiplier
                              0  // Write Constant
                            };
    SetCommTimeouts(hCDB_OUT_rd, &timeouts);
    // std::cout <<"Start of recv_without_break_condition_for_stackbase_and_stacklimit :"<<std::endl;
    std::string output;
    while (result != 258 && ok) {
        // On attends qu'il y ai écriture dans le buffer pendant un certains temps
        result = WaitForMultipleObjects(1, &hCDB_OUT_rd, FALSE, 1000);

        // On lit le buffer (la pipe)        
        ok = ReadFile(hCDB_OUT_rd, buffer, CDB_BUFFER_SIZE, &hasNbytes, NULL);
        // if (hasNbytes == 0) {
        //     std::cout << "TIMEOUT of READFILE"<<std::endl;
        // }
        
        // On créé une copie du buffer
        std::string msg(buffer, hasNbytes);
        output = msg;
        // On l'affiche
        if(needDisplay){
            std::cout << msg<<"-----"<<std::endl;
        }

        
        // Si CDB attends une entrée, on sort de la boucle. UTILISATION DES REGEX NECESSAIRES
        if (msg.rfind(">") == 5 || msg.rfind(">") == 9)
            
            break;
        // Utilisation de regex !! :) Je crois que ça marche
        if (std::regex_search(msg, m, endRegex)) {
            
            break;
        }

    }
        size_t pos2 = 0;
    std::string delimeter = "\n";
    std::string token;
    std::list<std::string> list_of_library;
    std::string stackBaseAddress,stackLimit;
    std::list<std::string> list_of_stack_address;

        
    while((pos2 = output.find(delimeter) )!=std::string::npos){
        token = output.substr(0,pos2);
        
            // std::cout<<" token : "<<token<<std::endl; 
            //On cherche tous les lignes qui ont le terme SafeSEH off afin de trouver les addresses
            int posStackBase = token.find("StackBase");
            int posStackLimit = token.find("StackLimit");
            std::regex addressRegex("[a-zA-Z0-9]{8}");
            std::smatch matches;
            
            std::string::const_iterator searchStart( token.cbegin() );
            // std::cout<<" Search with regex :"<<std::endl;
                        
            
                
            
            if(posStackBase!=-1){
                std::regex_search( searchStart, token.cend(), matches, addressRegex );
                // std::cout<<"StackBase find !"<<std::endl;
                stackBaseAddress = token.substr(posStackBase+22,8);
                list_of_stack_address.push_back(stackBaseAddress);
            }
            if(posStackLimit!=-1){
                std::regex_search( searchStart, token.cend(), matches, addressRegex );
                // std::cout<<"StackLimit find !"<<std::endl;
                stackLimit = token.substr(posStackLimit+22,8);
                list_of_stack_address.push_front(stackLimit);
            }
            // if(pos!=-1){
                
            //     std::string borne_librairie = output.substr(pos-39,17);
            //     list_of_library.push_back(borne_librairie);
            // }


        output.erase(0,pos2+delimeter.length());
    }
    
    
    // std::cout <<"fin of recv_without_break_condition_for_stackbase_and_stacklimit :"<<std::endl;

    ZeroMemory(buffer, CDB_BUFFER_SIZE);
    // std::cout << "NOUS SOMMES SORTIE" << std::endl;
    // bufSize, &hasNbytes, NULL);

    std::cout <<"stack base : "<<stackBaseAddress<<" stack limit : "<<stackLimit<<std::endl;
    return stackLimit+" "+stackBaseAddress;
}