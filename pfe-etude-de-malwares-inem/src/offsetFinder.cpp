/**
 * @file offsetFinder.cpp
 * @author Damien HEURET
 * @brief This file defines an OffsetFinder class!
 * @version 0.1
 * @date 2022-01-03
 * 
 * @copyright Copyright (c) 2022
 */

#include "../include/offsetFinder.h"

/**
 * @brief Construct a new Offset Finder object
 * @details default parameters are length = 0 and pattern = ""
 */
OffsetFinder::OffsetFinder() : m_length(0), m_pattern("") {}

/**
 * @brief Construct a new Offset Finder object
 * @details This constructor calls @ref setPattern() which generate the unique string.
 * @param length This is the length of the unique pattern string to be generated.
 */
OffsetFinder::OffsetFinder(int length) {
    m_length = length;
    setPattern();
}

/**
 * @brief Transform string containing hex value of characters into string of characters
 * @param hexString String containing HEX value as "0x32416333"
 * @return std::string Return corresponding ASCII characters (from hexString -> return "2Ac3").
 */
std::string OffsetFinder::hexToStr(std::string hexString) {
    uint32_t intValueOfStr = std::stoul(hexString, nullptr, 16); // Conversion string to unsigned int

    std::string charString(4, ' ');
    // charString[0] = static_cast<char>((intValueOfStr >> 24) & 0xFF); //On récupère l'octet le plus fort
    // charString[1] = static_cast<char>((intValueOfStr >> 16) & 0xFF);
    // charString[2] = static_cast<char>((intValueOfStr >> 8) & 0xFF);
    // charString[3] = static_cast<char>((intValueOfStr) & 0xFF); // jusqu'au moins fort

    charString[3] = static_cast<char>((intValueOfStr >> 24) & 0xFF); //On récupère l'octet le plus fort
    charString[2] = static_cast<char>((intValueOfStr >> 16) & 0xFF);
    charString[1] = static_cast<char>((intValueOfStr >> 8) & 0xFF);
    charString[0] = static_cast<char>((intValueOfStr) & 0xFF); // jusqu'au moins fort

    // std::cout<<"charString :"<<charString<<std::endl;
    return charString;
}

/**
 * @brief Search a certain sub pattern to the original pattern
 * 
 * @param subPattern String of 4 characters
 * @return dumb int value if pattern does not exist
 * @return "unsigned int" if the sub pattern has been found
 */
unsigned int OffsetFinder::searchPattern(std::string subPattern) {
    return m_pattern.find(hexToStr(subPattern));        
}

/**
 * @brief generate pattern depending on m_length
 * @details generate 26*26*10*3 possibilities in maximum (20'280 possibilities). Will stop and save in m_pattern when m_pattern length is equal to m_length.
 */
void OffsetFinder::setPattern() {
    // On se base sur un pattern où 3 (ou plus) rangé unique de symboles ASCII sont générés les uns après les autres. Par exemple : [A-Z][a-z][0-9] (cf metasploit -> 26*26*10 possibilités [6 760])
    
    // Reset du pattern :
    m_pattern = "";

    // On définit les valeurs de départ de chaque caractère !
    const char base_L_value = 'A';
    const char base_M_value = 'a';
    const char base_R_value = '0';

    // Les valeurs d'arrivé de chaque caractère !
    const char last_L_value = 'Z';
    const char last_M_value = 'z';
    const char last_R_value = '9';
    
    // On définit les variables qui vont prendre les valeurs au fur et à mesure
    char left = base_L_value;
    char middle = base_M_value;
    char right = base_R_value;
    
    // Compteur de character pour la création du pattern (sert de sortie de boucle)
    int charCounter = 0;

    // Utilisation des breakers pour sortir des boucles for
    int leftBreaker = 0;
    int middleBreaker = 0;

    for (left; (int)left <= (int)last_L_value; left = static_cast<char>(left + 1)) { // Boucle caractère gauche
        for (middle; (int)middle <= (int)last_M_value; middle = static_cast<char>(middle + 1)) { // boucle caractère milieu
            for (right; (int)right <= (int)last_R_value; right = static_cast<char>(right + 1)) { // boucle caractère droite
                if (charCounter == m_length) {break;} // Si on a atteint la longueur demandé on sort des boucles
                m_pattern += left; // Sinon on ajoute le prochain caractère
                charCounter += 1; // On incrémente le compteur qui trace la longueur de du pattern
                if (charCounter == m_length) {break;}
                m_pattern += middle; // Si on n'a toujours pas atteint le nombre de caractère requis on rajoute le suivant
                charCounter += 1;
                if (charCounter == m_length) {break;}
                m_pattern += right; // IDEM
                charCounter += 1;
            }
            if (charCounter == m_length) {break;} // On sort si le nbr de caractère est suffisant
            right = base_R_value; // Sinon on reset la valeur des digits
        }
        if (charCounter == m_length) {break;}
        middle = base_M_value; // Sinon on reset la valeur centrale
    }
}

/**
 * @brief Get generated pattern
 * 
 * @return std::string pattern
 */
std::string OffsetFinder::getPattern() {
    return m_pattern;
}

/**
 * @brief Set pattern length to be generated
 * @warning you should call @ref setPattern() "setPattern" to recreate pattern
 * 
 * @param length length of the new pattern
 */
void OffsetFinder::setLength(int length) {
    m_length = length;
}

/**
 * @brief get length on pattern
 * 
 * @return int length
 */
int OffsetFinder::getLength() {
    return m_length;
}