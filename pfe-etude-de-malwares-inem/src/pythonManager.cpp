/**
 * @file pythonManager.cpp
 * @author Quentin Averlant
 * @brief Interface to manage py file
 * @version 0.1
 * @date 2022-03-21
 * 
 * @copyright Copyright (c) 2022
 * 
 */
#include "../include/pythonManager.h"

/**
 * @brief Construct a new pythonManager object
 * 
 * @param fileName the name of file to work on
 */
PythonManager::PythonManager(std::string fileName)
{
    isRunning = false;

    // Security Attributes : 
    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    // Doit-on hérité des HANDLES ? (Oui pour rediriger les sorties et les entrées)
    saAttr.bInheritHandle = TRUE;
    // ça osef
    saAttr.lpSecurityDescriptor = NULL;

    // Création des pipes : h = HANDLE ; CDB <- Nom Processus Fils; IN/OUT <- Entrée ou Sortie de la sortie; rd/wr <- Sortie ou Entrée par rapport à notre programme.
    hCDB_IN_rd = NULL;
    hCDB_IN_wr = NULL;
    hCDB_OUT_rd = NULL;
    hCDB_OUT_wr = NULL;

    // Création des pipes
    CreatePipe(&hCDB_OUT_rd, &hCDB_OUT_wr, &saAttr, 0);
    CreatePipe(&hCDB_IN_rd, &hCDB_IN_wr, &saAttr, 0);

    // Startup information :
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(si);
    // On utilise les handles, et la synchronisation
    si.dwFlags = STARTF_USESTDHANDLES | SYNCHRONIZE;
    // Setup des entrées et sorties standard (redirection sur les pipes)
    si.hStdInput = hCDB_IN_rd;
    si.hStdOutput = hCDB_OUT_wr;
    si.hStdError = hCDB_OUT_wr;

    // On stock le nom du fichier sur lequel on doit s'attacher.
    fileToLaunch = fileName;

    // Commande pour lancer CDB
    cmdLine = "python.exe " + fileToLaunch;
}

/**
 * @brief Destroy the PythonManager::PythonManager object
 * 
 */
PythonManager::~PythonManager() {
    CloseHandle(hCDB_OUT_rd);
    CloseHandle(hCDB_IN_wr);
}

/**
 * @brief Exécute le fichier python 
 * 
 */
void PythonManager::run() {
    isRunning = true;

    CreateProcess(NULL,
        const_cast<char *>(cmdLine.c_str()),
        NULL,
        NULL,
        TRUE,
        NORMAL_PRIORITY_CLASS,
        NULL,
        NULL,
        &si,
        &pi);

    // Ferme les pipes du côté du fils. (On ne peut pas écrire et lire dans les mêmes côtés du pipe que le fils.)
    CloseHandle(hCDB_OUT_wr);
    CloseHandle(hCDB_IN_rd);
}

/**
 * @brief Stop PythonManager
 * 
 */
void PythonManager::stop() {
    isRunning = false;
    TerminateProcess(pi.hProcess, 0);
}


void PythonManager::write_file(std::string inputBuffer){
    std::ifstream exploit_1("exploit_1.py", std::ios_base::binary);
    std::ifstream exploit_2("exploit_2.py", std::ios_base::binary);
    std::ofstream exploit("exploit.py", std::ios_base::binary);
    exploit << exploit_1.rdbuf() << inputBuffer<< exploit_2.rdbuf();
}