/**
 * @file SaveParser.cpp
 * @author Damien HEURET
 * @brief This file handle saves and loads from config files
 * @version 0.1
 * @date 2022-01-04
 * 
 * @copyright Copyright (c) 2022
 * 
 */

#include "../include/SaveParser.h"

/**
 * @brief Construct a new save Parser::save Parser object
 * @details Create default structure of save object.
 */
SaveParser::SaveParser()
{
    m_narly = "narly.dll"; // NARLY PATH
    m_filename = ""; // EXEC PATH
    m_version = "";
    m_service = ""; // SERVICE NAME
    m_attach = "";
    m_eNeedsRestart = true; // EXEC NEEDS RESTART
    m_sNeedsRestart = true; // SERVICE NEEDS RESTART
    m_ip = "localhost"; // SERVER'S IP FOR ATTACK
    m_port = 80; // ATTACK'S PORT
    m_save = false; // DO WE SAVE ?

    // BAD CHARACTERS
    m_badChars = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
    "\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
    "\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
    "\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
    "\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
    "\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
    "\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
    "\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
    "\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
    "\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
    "\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
    "\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
    "\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
    "\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
    "\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
    "\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff";
    // JUMP ADDRESSE INSTRUCTIONS
    m_jmpEspAdr = 0x00000000;
    // OFFSET BOF
    m_offset = 0;
    m_lastStepDone = 0;
}

/**
 * @brief Function that first load user config file
 * @details take arg from properties.conf. If this file does not exist it will ask user to regenerate it. Print parameters
 * @return int -1 if problems, 0 if not.
 */
int SaveParser::setup(bool _setup) {
    // Open file as stream
    std::fstream userConf;
    // To read file line by line
    std::string line;

    CreateDirectory("Saves", NULL);
    // Open default file as input
    userConf.open("properties.conf", std::ofstream::in);
    // Check if file exist
    if (!userConf.good()) {
        // Close is file does not exist
        userConf.close();
        // answer of user
        std::string regenerate = "";
        std::cout << "Configuration file [properties.conf] is not found. Do you want to generate it? [y/n] : " << std::endl;
        // ask user to input
        std::cin >> regenerate;
        // Transform the answer to lowercases
        std::transform(regenerate.begin(), regenerate.end(), regenerate.begin(), [](unsigned char c){ return std::tolower(c); });
        // Cehck answer
        if (regenerate == "y" || regenerate == "yes" || _setup) {
                // Create new file
                userConf.open("properties.conf", std::ofstream::out);
                // default config string
                userConf << "# THIS IS A CONFIGURATION FILE FOR OUR PROGRAM\n# USE # TO COMMENTS LINES\n# COMMENTED LINES WILL NOT BE READ BY THE PROGRAM\n#\n# WARNING : For path element use \"/\" separator OR \"\\\\\"\n# PATH VARIABLE CAN BUT SHORTENED :\n# Relative or explicit path can be used\n\n# Narly is needed. This is the path to the narly.dll librairy\n# This is also possible : (relative path)\n# narly=\"narly.dll\"\nnarly=\"H:\\desktop\\narly.dll\"\n\n# This is the name of the program to test (.exe) \"Sync Breeze Client\" :\n# default : filename=\"C:\\Program Files (x86)\\Sync Breeze Enterprise\\bin\\syncbrc.exe\"\nfilename=\"C:\\Program Files (x86)\\Sync Breeze Enterprise\\bin\\syncbrc.exe\"\n\n# The next parameter is unecessary but can sort research and save data depending on it\n# This is a string, can be filled with version number etc\n#version=\"BoF_failure\"\nversion=\"1.0.0\"\n\n# The service's name of the process.\n# default : service=\"Sync Breeze Enterprise\"\nservice=\"Sync Breeze Enterprise\"\n\n# What CDB needs to be attached to (If it's same as filename it means cdb will attach to exec, else to a service) :\n# default : attach=\"syncbrs.exe\"\nattach=\"syncbrs.exe\"\n\n# Does executable need to be restarted after each attack ?\n# default : YES\nfileNeedRestart=\"YES\"\n\n# Does service need to be restarted after each attack ?\n# default : YES\nserviceNeedRestart=\"YES\"\n\n# IP of the server\nip=\"localhost\"\n\n# port to attack\nport=\"80\"\n\n# Do you want to save this file with results in subdir \"saves/filename\" ?\n# default : YES\nsave=\"YES\"";
                // close file
                userConf.close();
                std::cout << "\nYou can now edit properties.conf file to configure this program. ENJOY" << std::endl;
                return -1;
        }
        else {
                std::cout << "Exiting the program..." << std::endl;
                return -1;
        }
    }
    inputParam(userConf);
    // std::cout << "\nVoici les parametres charges\n" << std::endl;
    userConf.clear();
    userConf.seekg(0);
    // printConf(userConf);
    userConf.close();
    return 0;
}

/**
 * @brief Overloaded operator << : You can print all attribut by passing this instance as output. For exemple : SaveParser mySave; std::cout << mySave; // will work
 * 
 * @param os output stream default cout
 * @param rhs self reference
 * @return std::ostream& stream output
 */
std::ostream &operator<<(std::ostream &os, const SaveParser &rhs) {
    os << " m_narly: " << rhs.m_narly << std::endl
       << " m_filename: " << rhs.m_filename << std::endl
       << " m_version: " << rhs.m_version << std::endl
       << " m_service: " << rhs.m_service << std::endl
       << " m_attach: " << rhs.m_attach << std::endl
       << " m_eNeedsRestart: " << rhs.m_eNeedsRestart << std::endl
       << " m_sNeedsRestart: " << rhs.m_sNeedsRestart << std::endl
       << " m_ip: " << rhs.m_ip << std::endl
       << " m_port: " << rhs.m_port << std::endl
       << " m_save: " << rhs.m_save << std::endl
       << " m_badChars: " << rhs.m_badChars << std::endl
       << " m_jmpEspAdr: " << rhs.m_jmpEspAdr << std::endl
       << " m_offset: " << rhs.m_offset << std::endl;
    return os;
}

/**
 * @brief Used to print parameters in file
 * 
 * @param inputFile opened std::fstream file to read ! Take care to change pos of cursor 
 */
void SaveParser::printConf(std::fstream &inputFile) {
    std::string line;
    int findEQ, firstDQ, lastDQ;
    while(std::getline(inputFile, line)) {
        // ignore line if starts with "#"
        if (line.rfind("#", 0) != 0 && !line.empty()) {
            findEQ = line.find("=");
            firstDQ = line.find("\"");
            lastDQ = line.rfind("\"");

            std::string param = line.substr(0, findEQ);;
            std::string value = line.substr(firstDQ+1, lastDQ-firstDQ-1);
            std::cout << "\t" << param << "=" << value << std::endl;
        }
    }
    std::cout << std::endl;
}

/**
 * @brief Convert a integer into a hex in string in the format : '01','ff','4b'
 * 
 * @return Return the string of conversion
 */
std::string SaveParser::convert_int_to_string_in_hex(int number){
    std::string conversion;
    std::stringstream stream;
    stream << std::hex << number;
    if(number<16){
        conversion = "0"+stream.str();
    }else{
        conversion = stream.str();
    }
    return conversion;
}


/**
 * @brief WIP mean Work-In-Progress
 * @details Read WIP data like badchars, jmp esp Address or Offset
 */
void SaveParser::readWIP() {
    
}

/**
 * @brief (Only working if we use saves) - Load if it detects saved file or save if isn't
 * 
 */
void SaveParser::save() {
    if (!m_save)
        return;
    std::string choice = "";
    std::string path = (m_filename + "_" + m_version);
    //std::cout << path << std::endl;
    path = path.substr(path.rfind("\\"), path.length() - path.rfind("\\"));
    //std::cout << path << std::endl;
    path = path.erase(path.find(".exe"), 4);
    path.insert(0, "Saves");
    bool ret = CreateDirectory(path.c_str(), NULL); 
    /*if(!ret) {
        std::cout << "impossible de creer le dossier [" << path << "] Erreur : " << GetLastError() << std::endl;
    }*/
    std::fstream saveUConfig, savePConfig;
    // Open file in reading mode
    saveUConfig.open(path + "/properties.conf", std::fstream::in);
    if (false && saveUConfig.good()) { // If file opened that's mean a savefile exist
        std::cout << "Vous avez deja un fichier avec des parametres. " << std::endl;
        // Print parameters
        printConf(saveUConfig);
        // place cursor at beginning
        saveUConfig.clear();
        saveUConfig.seekg(0);
        // ask for import
        std::cout << "Voulez-vous les importer ? [y/n]" << std::endl;
        std::cin >> choice;
        // transforme to lowercase
        std::transform(choice.begin(), choice.end(), choice.begin(), [](unsigned char c){ return std::tolower(c); });
        // if user wants to import then
        if (choice == "y" | choice == "yes") {
            // import parameters
            inputParam(saveUConfig);
            // set cursor at beginning
            saveUConfig.clear();
            saveUConfig.seekg(0);
            std::cout << "Voici les nouveau parametres : " << std::endl;
            // print new parameters
            printConf(saveUConfig);
        }
        // else write config if we do have save parameter
        else if (true) {
            saveUConfig.close();
            saveUConfig.open(path + "/properties.conf", std::fstream::out);
            writeConf(saveUConfig);
        }
        // close file
        saveUConfig.close();
    }
    // if file does not exist and we do want to save :
    else if (m_save) {
        saveUConfig.close();
        // open file in writing mode
        saveUConfig.open(path + "/properties.conf", std::fstream::out);
        // write in file
        writeConf(saveUConfig);
        saveUConfig.close();
    }
    else {
        // else close the file
        saveUConfig.close();
    }
}

/**
 * @brief Read parameters and store them in this instance.
 * 
 * @param inputFile opened std::fstream file to read. Be aware of the cursor's pos before using it.
 */
void SaveParser::inputParam(std::fstream &inputFile) {
    std::string line;
    int findEQ, firstDQ, lastDQ;
    // read line per line
    while(std::getline(inputFile, line)) {
        // ignore line if starts with "#"
        if (line.rfind("#", 0) != 0 && !line.empty()) {
            // index of =
            findEQ = line.find("=");
            // index of both "
            firstDQ = line.find("\"");
            lastDQ = line.rfind("\"");
            // retrieve parameter (before =)
            std::string param = line.substr(0, findEQ);;
            // retrieve value (between quote)
            std::string value = line.substr(firstDQ+1, lastDQ-firstDQ-1);
            // PARSING
            if (param == "narly")
                this->setNarly(value);
            else if (param == "filename")
                this->setFilename(value);
            else if (param == "version")
                this->setVersion(value);
            else if (param == "fileNeedRestart")
                this->setENeedsRestart(value == "YES");
            else if (param == "serviceNeedRestart")
                this->setSNeedsRestart(value == "YES");
            else if (param == "service")
                this->setService(value);
            else if (param == "attach")
                this->setAttach(value);
            else if (param == "ip")
                this->setIp(value);
            else if (param == "port")
                this->setPort(std::stoi(value));
            else if (param == "save")
                this->setSave(value == "YES");
        }
    }
}

/**
 * @brief save data in specified file
 * 
 * @param outputFile opened std::fstream file as output to store data in it.
 */
void SaveParser::writeConf(std::fstream &outputFile) {
    // transform string to bool
    std::string doesExecRestart = m_eNeedsRestart ? "YES" : "NO";
    std::string doesServRestart = m_sNeedsRestart ? "YES" : "NO";
    std::string doWeSave = m_save ? "YES" : "NO";
    // writing in file
    outputFile << "# THIS IS A CONFIGURATION FILE FOR OUR PROGRAM\n# USE # TO COMMENTS LINES\n# COMMENTED LINES WILL NOT BE READ BY THE PROGRAM\n#\n# WARNING : For path element use \"/\" separator OR \"\\\\\"\n# PATH VARIABLE CAN BUT SHORTENED :\n# Relative or explicit path can be used\n\n# Narly is needed. This is the path to the narly.dll librairy\n# This is also possible : (relative path)\n# narly=\"narly.dll\"\nnarly=\"" << m_narly <<"\"\n\n# This is the name of the program to test (.exe) \"Sync Breeze Client\" :\n# default : filename=\"C:\\Program Files (x86)\\Sync Breeze Enterprise\\bin\\syncbrc.exe\"\nfilename=\"" << m_filename << "\"\n\n# The next parameter is unecessary but can sort research and save data depending on it\n# This is a string, can be filled with version number etc\n#version=\"BoF_failure\"\nversion=\""<< m_version <<"\"\n\n# The service's name of the process.\n# default : service=\"Sync Breeze Enterprise\"\nservice=\"" << m_service << "\"\n\n# What CDB needs to be attached to (If it's same as filename it means cdb will attach to exec, else to a service) :\n# default : attach=\"syncbrs.exe\"\nattach=\"" << m_attach << "\"\n\n# Does executable need to be restarted after each attack ?\n# default : YES\nfileNeedRestart=\"" << doesExecRestart << "\"\n\n# Does service need to be restarted after each attack ?\n# default : YES\nserviceNeedRestart=\""<< doesServRestart <<"\"\n\n# IP of the server\nip=\"" << m_ip << "\"\n\n# port to attack\nport=\"" << std::to_string(m_port) << "\"\n\n# Do you want to save this file with results in subdir \"saves/filename\" ?\n# default : YES\nsave=\"" << doWeSave << "\"";

}

std::string SaveParser::narly() const {
    return m_narly;
}

std::string SaveParser::version() const {
    return m_version;
}

void SaveParser::setVersion(const std::string &version) {
    m_version = version;
}

int SaveParser::getLastStepDone() const { 
    return m_lastStepDone;
}

void SaveParser::setLastStepDone(int lastStepDone) {
    m_lastStepDone = lastStepDone;
}

void SaveParser::setNarly(const std::string &narly) {
    m_narly = narly;
}

std::string SaveParser::filename() const {
    return m_filename;
}

void SaveParser::setFilename(const std::string &filename) { 
    m_filename = filename;
}

std::string SaveParser::service() const {
    return m_service;
}

void SaveParser::setService(const std::string &service) {
    m_service = service;
}


bool SaveParser::isENeedsRestart() const {
    return m_eNeedsRestart;
}

void SaveParser::setENeedsRestart(bool eNeedsRestart) {
    m_eNeedsRestart = eNeedsRestart;
}

bool SaveParser::isSNeedsRestart() const {
    return m_sNeedsRestart;
}
void SaveParser::setSNeedsRestart(bool sNeedsRestart) {
    m_sNeedsRestart = sNeedsRestart;
}

std::string SaveParser::ip() const {
    return m_ip;
}

void SaveParser::setIp(const std::string &ip) {
    m_ip = ip;
}

int SaveParser::port() const {
    return m_port;
}

void SaveParser::setPort(int port) {
    m_port = port;
}

bool SaveParser::isSave() const {
    return m_save;
}
void SaveParser::setSave(bool save) {
    m_save = save;
}

std::string SaveParser::badChars() const {
    return m_badChars;
}

void SaveParser::setBadChars(const std::string &badChars) {
    m_badChars = badChars;
}

unsigned int SaveParser::jmpEspAdr() const {
    return m_jmpEspAdr;
}

void SaveParser::setJmpEspAdr(unsigned int jmpEspAdr) {
    m_jmpEspAdr = jmpEspAdr;
}

unsigned int SaveParser::offset() const {
    return m_offset;
}

void SaveParser::setOffset(unsigned int offset) {
    m_offset = offset;
}
std::string SaveParser::getAttach() const {
    return m_attach;
}

void SaveParser::setAttach(const std::string &attach) {
    m_attach = attach;
}
